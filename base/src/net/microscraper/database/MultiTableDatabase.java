package net.microscraper.database;

import java.io.IOException;
import java.util.Hashtable;

/**
 * An implementation of {@link Database} whose subclasses store
 * {@link Result}s into separate tables, based off of their source's name.
 * @author talos
 *
 */
public final class MultiTableDatabase implements Database {
	
	/**
	 * String to prepend before table names to prevent collision
	 * with {@link #DEFAULT_TABLE_NAME}, and to prepend before column
	 * names to prevent collision with {@link #SCOPE_COLUMN_NAME}.
	 */
	public static final char PREPEND = '_';
	
	/**
	 * Name of {@link #defaultTable}.
	 */
	public static final String DEFAULT_TABLE_NAME = Scope.DEFAULT;
	
	/**
	 * Column name for the scope of the source, in join tables.
	 */
	public static final String SOURCE_COLUMN_NAME = "source";
	
	/**
	 * Column name for the scope of this row, in both result and join tables.
	 */
	public static final String SCOPE_COLUMN_NAME = "scope";
	
	/**
	 * Column name for the source join value in a join table.
	 */
	public static final String VALUE_COLUMN_NAME = "value";
	
	/**
	 * Default column names for {@link Updateable}s result table
	 * in {@link MultiTableDatabase}.
	 */
	public static final String[] RESULT_TABLE_COLUMNS = new String[] {
		SCOPE_COLUMN_NAME
	};
	
	/**
	 * Fixed columns for {@link Insertable} join table in {@link MultiTableDatabase}.
	 */
	public static final String[] JOIN_TABLE_COLUMNS = new String[] {
		SOURCE_COLUMN_NAME,
		SCOPE_COLUMN_NAME,
		VALUE_COLUMN_NAME
	};
	
	/**
	 * Mapping of scopes to result tables.
	 */
	private final Hashtable scopeResultTables = new Hashtable();

	/**
	 * Mapping of scopes to join tables.
	 */
	private final Hashtable scopeJoinTables = new Hashtable();
	
	/**
	 * A {@link UpdateableConnection} to use when generating tables.
	 */
	private final UpdateableConnection connection;
	
	/**
	 * The default result table.
	 */
	private Updateable defaultTable;
	
	/**
	 * Performs read operations, as {@link UpdateableConnection} does not support these.
	 */
	private final Database backingDatabase;
	
	/**
	 * Whether {@link #open()} has been called.
	 */
	private boolean isOpen = false;

	/**
	 * Make sure <code>columnName</code> doesn't overlap with a predefined column in
	 * {@link RESULT_TABLE_COLUMNS}.
	 * @param tableName The {@link String} possible table name to check.
	 * @return A prepended version of <code>tableName</code> if necessary.
	 */
	private String cleanColumnName(String columnName) {
		for(int i = 0 ; i < RESULT_TABLE_COLUMNS.length ; i ++) {
			if(columnName.equals(RESULT_TABLE_COLUMNS[i])) {
				return PREPEND + columnName;
			}
		}
		return columnName;
	}
	
	/**
	 * Make sure <code>tableName</code> doesn't overlap with the {@link #DEFAULT_TABLE_NAME}.
	 * @param tableName The {@link String} possible table name to check.
	 * @return A prepended version of <code>tableName</code> if necessary.
	 */
	private String cleanTableName(String tableName) {
		return tableName.equals(DEFAULT_TABLE_NAME) ? PREPEND + tableName : tableName;
	}
	
	/**
	 * 
	 * @throws IllegalStateException If {@link MultiTableDatabase} has not been opened.
	 */
	private void ensureOpen() throws IllegalStateException {
		if(isOpen == false) {
			throw new IllegalStateException("Must open database before using it.");
		}
	}
	
	/**
	 * Private method called by {@link #storeOneToMany(Scope, String, String)}
	 * and {@link #storeOneToMany(Scope, String)}, where <code>value</code>
	 * can be null, and <code>scope</code> has already been generated by the
	 * {@link #backingDatabase}.
	 * @param source The {@link Scope} source.
	 * @param scope The new {@link Scope}.
	 * @param value An optional value to store in the join table.  Can be <code>null</code>.
	 */
	private void storeOneToMany(Scope source, Scope scope, String value)
			throws TableManipulationException, IOException {
		if(!scopeResultTables.containsKey(scope)) {
			scopeResultTables.put(scope,
					connection.getIOTable(cleanTableName(scope.getName()), RESULT_TABLE_COLUMNS));
			scopeJoinTables.put(scope,
					connection.getInsertable(source.getName() + PREPEND + cleanTableName(scope.getName()), JOIN_TABLE_COLUMNS));
		}
		Updateable resultTable = (Updateable) scopeResultTables.get(scope);
		Insertable joinTable = (Insertable) scopeJoinTables.get(scope);
		
		// Insert new value into joinTable
		Hashtable joinInsert = new Hashtable();
		joinInsert.put(SCOPE_COLUMN_NAME, scope.getID().asString());
		joinInsert.put(SOURCE_COLUMN_NAME, scope.getID().asString());
		if(value != null) {
			joinInsert.put(VALUE_COLUMN_NAME, value);
		}
		joinTable.insert(joinInsert);
		
		// Insert new value into resultTable
		Hashtable resultInsert = new Hashtable();
		resultInsert.put(SCOPE_COLUMN_NAME, scope.getID().asString());
		resultTable.insert(resultInsert);
	}
	
	/**
	 * Create a {@link MultiTableDatabase} using another database for
	 * retrieving values.
	 */
	public MultiTableDatabase(Database backingDatabase,
			UpdateableConnection connection) {
		this.backingDatabase = backingDatabase;
		this.connection = connection;
	}
	
	/**
	 * Opens {@link #connection} and {@link #backingDatabase}, and creates the {@link #defaultTable}.
	 */
	public void open() throws IOException {
		connection.open();
		backingDatabase.open();
		defaultTable = connection.getIOTable(DEFAULT_TABLE_NAME, RESULT_TABLE_COLUMNS);
		isOpen = true;
	}
	

	/**
	 * Closes {@link #connection} and {@link #backingDatabase}.
	 */
	public void close() throws IOException {
		backingDatabase.close();
		connection.close();
	}
	
	/**
	 * Just calls the same method for {@link #backingDatabase}.
	 */
	public void storeOneToOne(Scope source, String name)
			throws TableManipulationException, IOException {
		ensureOpen();
		backingDatabase.storeOneToOne(source, name);
	}
	
	/**
	 * Update the table of source scope with name and value.  Create the column for the name
	 * if it doesn't already exist.
	 */
	public void storeOneToOne(Scope source, String name, String value)
			throws TableManipulationException, IOException {
		ensureOpen();
		backingDatabase.storeOneToOne(source, name, value);
		
		Updateable table = (Updateable) scopeResultTables.get(source);
		if(!table.hasColumn(cleanColumnName(name))) {
			table.addColumn(cleanColumnName(name));
		}
		Hashtable map = new Hashtable();
		map.put(cleanColumnName(name), value);
		
		table.update(SCOPE_COLUMN_NAME, source.getID(), map);
	}
	
	/**
	 * Generate a new scope, and generate a new table for it if it doesn't exist yet.
	 * If the table doesn't exist yet, also create a new join table.
	 * Enter in new new rows to both table, sans a value for the join table.
	 */
	public Scope storeOneToMany(Scope source, String name)
			throws TableManipulationException, IOException {
		ensureOpen();
		Scope scope = backingDatabase.storeOneToMany(source, name);
		storeOneToMany(source, scope, null);
		return scope;
	}

	/**
	 * Generate a new scope, and generate a new table for it if it doesn't exist yet.
	 * If the table doesn't exist yet, also create a new join table.
	 * Enter in new rows to both table, including a value for the join table.
	 */
	public Scope storeOneToMany(Scope source, String name, String value)
			throws TableManipulationException, IOException {
		ensureOpen();
		Scope scope = backingDatabase.storeOneToMany(source, name, value);
		storeOneToMany(source, scope, value);
		return scope;
	}

	public String get(Scope scope, String key) {
		ensureOpen();
		return backingDatabase.get(scope, key);
	}

	public Scope getDefaultScope() throws IOException {
		ensureOpen();
		Scope scope = backingDatabase.getDefaultScope();
		scopeResultTables.put(scope, defaultTable);
		
		Hashtable map = new Hashtable();
		map.put(SCOPE_COLUMN_NAME, scope.getID().asString());
		defaultTable.insert(map);
		
		return scope;
	}

	public String toString(Scope scope) {
		return backingDatabase.toString(scope);
	}
}
