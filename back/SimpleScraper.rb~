#!/usr/bin/ruby

###
#   SimpleScraper Back 0.0.1
#
#   Copyright 2010, AUTHORS.txt
#   Licensed under the MIT license.
#
#   back.rb : Sinatra paths.
###

require 'rubygems'
require 'db'
require 'sinatra'

# CONFIG
configure do
  set :raise_errors, true
  set :show_exceptions, false
end

# GET

def serve_page(location)
  if(File.exists?(location))
    File.open(location)
  else
    'Could not open ' + location
  end
end

# Serve the front end page.
get '/front/' do
  serve_page('../front/index.html')
end

get '/front/js/:page' do
  serve_page('../front/js/' + params[:page])
end

get '/front/css/:page' do
  serve_page('../front/css/' + params[:page])
end

# Display the available resources.
get '/' do
  ['type/', 'gatherer/']
end

# Get a list of all the available areas.
get '/area/' do
  Area.identify_all.to_json
end

# Get details on a specific area.
get '/area/:name' do
  @area = Area.first(:name => params[:name]) or return not_found
  @area.export.to_json
end

# Get a list of all the available types.
get '/type/' do
  Type.identify_all.to_json
end

# Get details on a specific type.
get '/type/:name' do
  @type = Type.first(:name => params[:name]) or return not_found
  @type.export.to_json
end

# Get a publish field.
get '/type/:type/publish/:publish' do
  @type = Type.first(:name => params[:type]) or return not_found
  @publish = @type.publish_fields.first(:name => params[:publish]) or return not_found
  @publish.export.to_json
end

# Get a list of all the available Informations.
get '/type/:type/information/' do
  Type.first(:name => params[:type]).informations.identify_all.to_json
end

# Get details on an Information by name.
get '/type/:type/information/:information' do
#  @information = Information.first(:type_name => params[:type], :name => params[:name]) or return not_found
#  @information.export.to_json
#  Type.first(:name => params[:type]).informations.first(:name => 
  Information.first(:type_name => params[:type], :name => params[:information]).export.to_json
end

# Get a list of all the available Informations of a specific type in a specific area.
get '/information/:type/in/:area' do
#  @information = Area.first(:name => params[:area]).informations.first(:type_name => params[:type]) or return not_found
#  @information.to_json
#  Information.all(:type => params[:type]
  @area = Area.first(:name => params[:area]) or return not_found
  @area.informations.identify_all(:type_name => params[:type]).to_json
end


# Get a list of all the available Gatherers.
get '/gatherer/' do
  Gatherer.identify_all.to_json
end

# Get details on a specific Gatherer.
get '/gatherer/:name' do
  Gatherer.first(:name => params[:name]).export.to_json
end

get '/gatherer/:gatherer/url/' do
  Gatherer.first(:name => params[:gatherer]).urls.identify_all.to_json
end

get '/gatherer/:gatherer/url/:url' do
  nil
end

get '/gatherer/:gatherer/get/' do
  Gatherer.first(:name => params[:gatherer]).gets.identify_all.to_json
end

get '/gatherer/:gatherer/get/:get' do
  Gatherer.first(:name => params[:gatherer]).gets.first(:name => params[:get]).export.to_json or not_found
end

get '/gatherer/:gatherer/post/' do
  Gatherer.first(:name => params[:gatherer]).posts.identify_all.to_json
end

get '/gatherer/:gatherer/post/:post' do
  Gatherer.first(:name => params[:gatherer]).posts.first(:name => params[:post]).export.to_json or not_found
end

get '/gatherer/:gatherer/header/' do
  Gatherer.first(:name => params[:gatherer]).headers.identify_all.to_json
end

get '/gatherer/:gatherer/header/:header' do
  Gatherer.first(:name => params[:gatherer]).headers.first(:name => params[:header]).export.to_json or not_found
end

get '/gatherer/:gatherer/cookie/' do
  Gatherer.first(:name => params[:gatherer]).cookies.identify_all.to_json
end

get '/gatherer/:gatherer/cookie/:cookie' do
  Gatherer.first(:name => params[:gatherer]).cookies.first(:name => params[:cookie]).export.to_json or not_found
end

# PUT / POST / DELETE

# Create a new type.
put '/type/:name' do
  @type = Type.first_or_new(:name => params[:name])
  @type.save ? true.to_json : {:type => @type.errors.to_a}.to_json
end

# Delete a type.  This can only be done if there are no dependencies.
delete '/type/:name' do
  @type = Type.first(:name => params[:name]) or return not_found
  @type.destroy
  @type.destroyed ? true.to_json : {:type => @type.errors.to_a }.to_json
end

# Add a publish_field to a type.
put '/type/:type/publish/:publish_field' do
  @type = Type.first(:name => params[:type]) or return not_found
  @publish_field = PublishField.first_or_new(:name => params[:publish_field])
  @type.publish_fields << @publish_field
  @type.save ? true.to_json : {:type => @type.errors.to_a, :publish_field => @publish_field.errors.to_a}.to_json
end

# Delete a publish_field from a type.
delete '/type/:type/publish/:publish_field' do
  @type = Type.first(:name => params[:type]) or return not_found
  @type.publish_fields.delete(@type.first(:name => params[:publish_field]))
  @type.save ? true.to_json : {:type => @type.errors.to_a}.to_json
end

# Create a new Area.
put '/area/:area' do
  @area = Area.first_or_new(:name => params[:area])
  @area.save ? true.to_json : {:area => @area.errors.to_a }.to_json
end

# Delete an area.
delete '/area/:area' do
  @area = Area.first(:name => params[:area]) or return not_found
  @area.destroy
  @area.destroyed ? true.to_json : {area => @area.errors.to_a }.to_json
end

# Add a DefaultField to an Area.
put '/area/:area/default/:name' do
  @area = Area.first(:name => params[:area]) or return not_found
  @default_field = DefaultField.first_or_new(:name => params[:name], :value => params[:value])
  @area.default_fields << @default_field
  @area.save ? true.to_json : {:area => @area.errors.to_a, :default_field => @default_field.errors.to_a }.to_json
end

# Delete a DefaultField from an Area.
delete '/area/:area/default/:name' do
  @area = Area.first(:name => params[:area]) or return not_found
  @default_field = @area.default_fields.first(:name => params[:name]) or return not_found
  @area.default_fields.delete(@default_field)
  @area.save ? true.to_json : {:area => @area.errors.to_a }.to_json
end

# Create a new Information.
put '/information/:type/:name' do
  @type = Type.first(:name => params[:type]) or return not_found

  @information = Information.first_or_new(:type => @type, :name => params[:name])

  @information.save ? true.to_json : {:information => @information.errors.to_a, :area => @area.errors.to_a, :type => @type.errors.to_a}.to_json
end

# Tag an existing Information with a new Area.  Creates area if it doesn't exist yet.
put '/information/:type/:name/area/:area' do
  @information = Information.first(:type_name => params[:type], :name => params[:name]) or return not_found
  
  @area = Area.first_or_create(:name => params[:area])
  @information.areas << @area

  @information.save ? true.to_json : {:information => @information.errors.to_a, :area => @area.errors.to_a}.to_json
end

# Delete an Area tag from an information.
delete '/information/:type/:name/area/:area' do
  @area = Area.first(:name => params[:name]) or return not_found
  @information = Information.first(:type_name => params[:type], :name => params[:name]) or return not_found
  @information.areas.delete(@area)
  @information.save ? true.to_json : {:information => @information.errors.to_a, :area => @area.errors.to_a}.to_json
end

# Add a gatherer to an Information.
put '/information/:type/:name/gatherer/:gatherer' do
  @information = Information.first(:type_name => params[:type], :name => params[:name]) or return not_found
  @gatherer = Gatherer.first(:name => params[:gatherer]) or return not_found

  @information.gatherers << @gatherer
  @information.save ? true.to_json : {:information => @information.errors.to_a, :gatherer => @gatherer.errors.to_a}.to_json
end

# Delete a Gatherer from an Information.  Does not eliminate the Gatherer itself.
delete '/information/:type/:name/gatherer/:gatherer' do
  @information = Information.first(:type_name => params[:type], :name => params[:name]) or return not_found
  @gatherer = @information.gatherers.first(:name => params[:gatherer]) or return not_found
  @information.gatherers.delete(@gatherer)
  @information.save ? @information.to_json : {:information => @information.errors.to_a }.to_json
end

# Add a ToField to an Information.  Regex is inside the post.
put '/information/:type/:name/:input_field/:match_number/to/:destination_field' do
  @information = Information.first(:type_name => params[:type], :name => params[:name]) or return not_found
  @to_field = ToField.first_or_new(:input_field => params[:input_field], :match_number => params[:match_number], :regex => params[:regex], :destination_field => params[:destination_field])
  @information.to_fields << @to_field
  @information.save ? true.to_json : {:information => @information.errors.to_a, :to_field => @to_field.errors.to_a}.to_json
end

# Delete a ToField from an Information
delete '/information/:type/:name/:input_field/:match_number/to/:destination_field' do
  @information = Information.first(:type_name => params[:type], :name => params[:name]) or return not_found
  @to_field = @information.to_fields.first(:input_field => params[:input_field], :match_number => params[:match_number], :destination_field => params[:destination_field]) or return not_found
  @information.to_fields.delete(@to_field)
  @information.save ? true.to_json : {:information => @information.errors.to_a }.to_json
end

# Add a ToInformation to an Information.
put '/information/:type/:name/:input_field/to/information/:destination_type/:destination_name/:destination_field' do
  @information = Information.first(:type_name => params[:type], :name => params[:name]) or return not_found
  @destination_information = Information.first(:type_name => params[:destination_type], :name => params[:destination_name]) or return not_found
  @to_information = ToInformation.first_or_new(:input_field => params[:input_field], :regex => params[:regex], :destination_information => @destination_information, :destination_field => params[:destination_field])
  @information.to_informations << @to_information
  @information.save ? true.to_json : {:information => @information.errors.to_a, :destination_information => @destination_information.errors.to_a, :to_information => @to_information.errors.to_a}.to_json
end

# Delete a ToInformation from an Information.
delete '/information/:type/:id/:input_field/to/information/:destination_type/:destination_name/:destination_field' do
  @information = Area.first(:name => params[:area]).informations.first(:type_name => params[:type]) or return not_found
  @destination_information = Information.first(:type_name => params[:destination_type], :name => params[:destination_name]) or return not_found
  @to_information = @information.first(:input_field => params[:input_field], :regex => params[:regex], :destination_information => @destination_information, :destination_field => params[:destination_field]) or return not_found
  
  @information.to_informations.delete(@to_information)
  @information.save ? true.to_json : {:information => @information.errors.to_a, :destination_information => @destination_information.errors.to_a}.to_json
end


# Create a new Gatherer.
put '/gatherer/:name' do
  @gatherer = Gatherer.first_or_new(:name => params[:name]) or return not_found
  @gatherer.save ? true.to_json : {:gatherer => @gatherer.errors.to_a}.to_json
end

# Delete a Gatherer.
delete '/gatherer/:name' do
  @gatherer = Gatherer.first(:name => params[:name]) or return not_found
  @gatherer.destroy
  @gatherer.destroyed ? true.to_json : {:gatherer => @gatherer.errors.to_a}.to_json
end

# Add a parent to a Gatherer.
put '/gatherer/:child/parent/:parent' do
  @child =  Gatherer.first(:name => params[:child]) or return not_found
  @parent = Gatherer.first(:name => params[:parent]) or return not_found
  @child.parent = @parent
  @child.save ? true.to_json : {:parent => @parent.errors.to_a, :child => @child.errors.to_a }.to_json
end

# Remove a parent relationship from a Gatherer. Does not eliminate the parent.
delete '/gatherer/:child/parent' do
  @child =  Gatherer.first(:name => params[:child]) or return not_found
  @child.parent.destroy
  @child.save ? true.to_json : {:child => @child.errors.to_a}.to_json
end

# Add a child to a Gatherer.
put '/gatherer/:parent/child/:child' do
  @child =  Gatherer.first(:name => params[:child]) or return not_found
  @parent = Gatherer.first(:name => params[:parent]) or return not_found
  @child.parent = @parent
  @child.save ? true.to_json : {:child => @child.errors.to_a, :parent => @parent.errors.to_a}.to_json
end

# Remove a child relationship from a Gatherer. Does not eliminate the child.
# Fails if the child is not a child of the specified parent.
delete '/gatherer/:parent/child/:child' do
  @parent = Gatherer.first(:name => params[:parent]) or return not_found
  @parent.children.delete(@parent.children.first(:name => params[:child]))
  @parent.save ? true.to_json : {:parent => @parent.errors.to_a}.to_json
end

# Add a URL to a Gatherer.  Value is in the post data.
put '/gatherer/:gatherer/url' do
  @gatherer = Gatherer.first(:name => params[:gatherer]) or return not_found
  @url = @gatherer.urls.first_or_new(:name => params[:value])
  @gatherer.save ? true.to_json : {:gatherer => @gatherer.errors.to_a, :url => @url.errors.to_a}.to_json
end

# Delete a URL from a gatherer.
delete '/gatherer/:gatherer/url/:value' do
  @gatherer = Gatherer.first(:name => params[:gatherer]) or return not_found
  @url = @gatherer.urls.first(:name => params[:value])
  @url.destroy
  @gatherer.destroyed ? true.to_json : {:gatherer => @gatherer.errors.to_a}.to_json
end

# Add a GET to a Gatherer.  Value is in the post data.
put '/gatherer/:gatherer/get/:name' do
  @gatherer = Gatherer.first(:name => params[:gatherer]) or return not_found
  @get = @gatherer.gets.first_or_new(:name => params[:name], :value => params[:value])
  @gatherer.save ? true.to_json : {:gatherer => @gatherer.errors.to_a, :get => @get.errors.to_a}.to_json
end

# Delete a GET from a Gatherer.
delete '/gatherer/:gatherer/get/:name' do
  @gatherer = Gatherer.first(:name => params[:gatherer]) or return not_found
  @gatherer.gets.first(:name => params[:name]).destroy
  @gatherer.save ? true.to_json : {:gatherer => @gatherer.errors.to_a}.to_json
end

# Add a POST to a Gatherer.  Value is in the post data.
put '/gatherer/:gatherer/post/:name' do
  @gatherer = Gatherer.first(:name => params[:gatherer]) or return not_found
  @post = @gatherer.posts.first_or_new(:name => params[:name], :value => params[:value])
  @gatherer.save ? true.to_json : {:gatherer => @gatherer.errors.to_a, :post => @post.errors.to_a}.to_json
end

# Delete a POST from a Gatherer.
delete '/gatherer/:gatherer/post/:name' do
  @gatherer = Gatherer.first(:name => params[:gatherer]) or return not_found
  @gatherer.posts.first(:name => params[:name]).destroy
  @gatherer.save ? true.to_json : {:gatherer => @gatherer.errors.to_a}.to_json
end

# Add a Header to a Gatherer.  Value is in the post data.
put '/gatherer/:gatherer/header/:name' do
  @gatherer = Gatherer.first(:name => params[:gatherer]) or return not_found
  @header = @gatherer.headers.first_or_new(:name => params[:name], :value => params[:value])
  @gatherer.save ? true.to_json : {:gatherer => @gatherer.errors.to_a, :header => @header.errors.to_a}.to_json
end

# Delete a Header from a Gatherer.
delete '/gatherer/:gatherer/header/:name' do
  @gatherer = Gatherer.first(:name => params[:gatherer]) or return not_found
  @gatherer.headers.first(:name => params[:name]).destroy
  @gatherer.save ? true.to_json : {:gatherer => @gatherer.errors.to_a}.to_json
end 

# Add a Cookie to a Gatherer. Value is in the post data.
put '/gatherer/:gatherer/cookie/:name' do
  @gatherer = Gatherer.first(:name => params[:gatherer]) or return not_found
  @cookie = @gatherer.cookies.first_or_new(:name => params[:name], :value => params[:value])
  @gatherer.save ? true.to_json : {:gatherer => @gatherer.errors.to_a, :cookie =>  @cookie.errors.to_a}.to_json
end

# Delete a Cookie from a Gatherer.
delete '/gatherer/:gatherer/cookie/:name' do
  @gatherer = Gatherer.first(:name => params[:gatherer]) or return not_found
  @gatherer.cookies.first(:name => params[:name]).destroy
  @gatherer.save ? true.to_json : {:gatherer => @gatherer.errors.to_a}.to_json
end

error do
  puts 'Sinatra Error: ' + env['sinatra.error']
  'Sinatra Error: ' + env['sinatra.error'].name
end

not_found do
  nil.to_json
end

`tests/test.sh`
